# 2장 몽고DB 기본

몽고디비는,

- 데이터의 기본 단위는 도큐먼트이고 관계형 디비의 행과 유사하다.(더 다양한 자료 표현 가능 → 이 뭘까?)
- 컬렉션은 동적 스키마가 있는 테이블과 같다.(동적 스키마?)
- 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 독립적인 데이터베이스를 호스팅한다.
- 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 “_id”를 가진다.
- 몽고 셸과 함께 배포된다. 몽고의 인스턴스를 관리하고 쿼리 언어로 데이터를 조작하며 스크립트를 로드할 수 있는 자바스크립트 해석기(Javascript interpreter)가 있다.

## 2.1 도큐먼트

도큐먼트는 정렬된 키와 연결된 값의 집합으로 이루어져 있다. 표현 방식은 대부분의 언어에서 맵, 해시, 딕셔너리와 같은 자료구조를 가진다. 예를 들어 자바스크립트에서 도큐먼트는 객체로 표현된다.

```json
{"greeting" : "Hello, world!"}
```

도큐먼트의 값은 단지 blob형이 아니고, 값은 데이터형 또는 내장 도큐먼트 전체가 되기도 한다. 도큐먼트의 키는 문자열이고 몇 가지 예외를 제외하면 어떤 UTF-8 문자든 쓸 수 있다.

- \0(null)을 포함하지 않는다. 키의 끝을 나타내는 데 사용된다.
- . 과 $ 문자는 특정 상황에서만 사용해야 하고 보통 예약어로 취급해야 한다.

```json
{"count":5}
{"count":"5"}
```

위의 두 다큐먼트는 서로 다르다. 또, 몽고디비에서 키는 중복될 수 없다.

```json
{"greeting":"Hello", "greeting":"Mongo DB!"}
```

## 2.2 컬렉션

컬렉션은 도큐먼트의 모음이다. 관계형 디비의 테이블에 대응된다.

### 2.2.1. 동적 스키마

컬렉션은 동적 스키마를 가진다. 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다. 

다른 구조의 도큐먼트라도 같은 컬렉션에 저장할 수 있는데 왜 별도의 컬렉션이 필요할까?

1. 같은 컬렉션에 저장하면 개발자와 관리자가 번거로워진다. 쿼리한 코드가 다른 구조의 도큐먼트를 다루지 못할 수도 있기 때문이다.
2. 컬렉션 별로 목록을 뽑으면 한 컬렉션 내에서 목록을 뽑을 때보다 훨씬 빠르다.
3. 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성(data locality)에 좋다. 컬렉션에서 추출할 때 디스크 탐색 시간이 더 짧다.
4. 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 해서 컬렉션 별로 인덱스를 정의해야 한다.

스키마를 만들고 도큐먼트를 그룹화해서 정의하면 도큐먼트 유효성 검사, 객체-도큐먼트 매핑 라이브러리를 이용할 수 있다.

### 2.2.2. 네이밍

컬렉션은 이름으로 식별되며 몇 가지 예외를 제외하고 어떤 UTF-8문자열도 쓸 수 있다.

- 빈 문자열(””)은 유효한 컬렉션 명이 아니다.
- \0(null)은 컬렉션 명의 끝을 의미하기 때문에 사용할 수 없다.
- system. 으로 시작하는 컬렉션 명은 예약어이다.
    - system.users : 데이터베이스 사용자 정보
    - system.namespaces: 디비 모든 컬렉션 정보
- 사용자가 만든 컬렉션에는 예약어인 $를 포함할 수 없다.

#### 서브컬렉션

서브컬렉션의 네임스페이스에 마침표(.)를 사용해서 컬렉션을 체계화한다. 예를 들면 blog.posts, blog.authors 라는 컬렉션을 가질 수 있고, 이는 체계화를 위한 용도이고 blob이나 자식커렉션의 의미가 아니다.

- 큰 파일을 저장하는 프로토콜인 GridFS는 콘텐츠 데이터와는 별도로 메타데이터를 저장하는 데 서브컬렉션을 사용한다.
- 대부분의 드라이버는 서브컬렉션에 접근하는 문법을 제공한다.

## 2.3 데이터베이스

몽고디비는 컬렉션에 도큐먼트를 그룹화하고, 데이터베이스에 컬렉션을 그룹화한다. 단일 인스턴스는 여러 데이터베이스를 호스팅할 수 있고 각 데이터베이스를 완전히 독립적으로 취급할 수 있다. 한 애플리케이션의 데이터를 동일한 데이터베이스에 저장하는 것은 좋은 방식이다. 데이터베이스를 나누면 하나의 몽고디비 서버에서 여러 애플리케이션이나 여러 사용자 데이터를 저장할 떄 유용하다.(→ 몽고도 디비를 나눌 수 있으니까 별도의 트랜잭션 매니저를 만드는 게 좋겠다.)

데이터베이스는 컬렉션과 마찬가지로 이름으로 식별되고 몇 가지 제한이 있다.

1. 빈 문자열(””)은 쓸 수 없다.
2. / , \ , . , ‘ ‘, * , < ,> , : , | , ? , $ , \0(null) 은 쓸 수 없다.
3. 대소문자를 구별한다.
4. 최대 64바이트이다. (영문만 쓰면 64자)

특별한 의미론(시멘틱)을 갖는 예약된 데이터베이스도 있다.

### admin

인증(authentification)과 권한 부여(authorization) 역할을 한다. 일부 관리 작업은 admin 에 대한 접근이 필요하다(19장).

### local

단일 서버에 대한 데이터를 저장한다. 복제 셋(replica set)에서 local은 복제 프로세스에 사용된 데이터를 저장하고, local 자체는 복제되지 않는다(10장)

### config

샤딩된 몽고 디비 클러스터(14장)는 config 에 각 샤드의 정보를 저장한다.

데이터베이스.컬렉션명 하면 네임스페이스를 얻는다. 예를 들어서 cms.blog.posts 네임스페이스는 cms 데이터베이스의 blog.posts 컬렉션을 사용하는 것이다. 네임스페이스의 최대 길이는 120바이트이지만 실제로는 100바이트보다 짧아야 한다.

## 2.4 몽고디비 시작

```bash
> mongod
```

argument 없이 실행하면 기본 데이터 디렉토리로 /data/db 를 사용하고, 존재하지 않거나 권한이 없으면 서버가 시작되지 않는다.

## 2.5 몽도디비 셸 소개

명령행에서 몽고디비 인스턴스와 상호작용하는 자바스크립트 셸을 제공하며, 관리 기능이나 실행 중인 인스턴스 점검, 간단한 기능 시험 등을 할 수 있다.

### 2.5.1 셸 실행

```bash
> mongo
> x = 200;
200
> x/5;
40
```

또, 표준 자바스크립트 라이브러리의 모든 기능을 사용할 수 있다.

```bash
> Math.sin(Math.PI / 2)
1
> new Date("20109/1/1");
ISODATE("2019091091T05:00:00Z")
```

자바스크립트 함수를 정의하고 호출할 수도 있다. 엔터키를 눌렀을 때 구문이 완료되지 않았으면 계속 명령어를 입력할 수 있다. 엔터를 3회 누르면 작성하던 명령을 취소하고 > 프롬프트를 반환한다.

### 2.5.2 몽고디비 클라이언트

셸은 시작할 때 test 데이터베이스에 연결하고 데이터베이스 연결을 전역 변수 db에 할당해서 접근한다.

```bash
> db
test
```

SQL 셸 사용자에게 친숙한 추가 기능을 포함해서 편리한 문법을 제공한다.

```bash
> use video //video 데이터베이스 사용 
> db
video
> db.movies //movies 컬렉션 반환 
```

### 2.5.3 셸 기본 작업

#### 생성

insertOne 함수는 컬렉션에 도큐먼트를 추가한다.

```bash
movie = {"title" : "Star Wars", "director": "George Lucas", "year": 1977}
db.movies.insertOne(movie)
db.getCollection("movie").insertOne(movie)
db.getCollection("movie").find({}).pretty()
```

“_id” 키가 추가됐다.

#### 읽기

find와 findOne으로 컬렉션을 쿼리한다.

```bash
> db.movies.findOne()
db.getCollection("movie").find({})
```

쿼리 도큐먼트 형태로 조건 전달할 수 있다.(4장)

#### 갱신

updateOne을 사용하고, 매개변수는 최소 2개이다. 첫 번째는 수정할 도큐먼트를 찾고, 두 번째는 갱신 작업을 설명한다. 갱신은 set을 이용한다.(3.3장)

```bash
> db.movies.updateOne({title: "Star Wars'}, ...{$set: {reviews:[]}})
db.getCollection("movie").updateOne({"title":"Star Wars"}, {$set: {"title":"Star Ward Updated"}})
```

#### 삭제

deleteOne과 deleteMany는 도큐먼트를 데이터베이스에서 영구적으로 삭제한다. 필터 도큐먼트로 삭제 조건을 지정한다.

```bash
> db.movies.deleteOne({title:"Star Wars"})
db.getCollection("movie").deleteOne({"title":"Star Wars"})
```

## 2.6 데이터형

### 2.6.1 기본 데이터형

JSON 과 닮았지만 JSON은 데이터형이 null, bool, number, string, array, object만 지원하기 때문에 표현이 제한적이다. 몽고는 키값 쌍 성질을 유지하면서 추가적인 데이터형을 지원한다.

#### null

```json
{"x": null}
```

#### 불리언

```json
{"x":true}
```

#### 숫자

64비트 부동소수점 수를 기본으로 사용한다.

```json
{"x":3}
```

4바이트나 8바이트 부호 정수는 NumberInt나 NumberLong을 사용한다.

```json
{"x":NumberInt("3")}
```

#### 문자

UTF-8이면 어떤 문자든 표현가능

```json
{"x": "foobar"}
```

#### 날짜

1970년 1월 1일부터 1/1000 초 단위로 나타내는 64비트 정수로 저장한다. 표준 시간대(time zone)는 저장하지 않는다.

```json
{"x":new Date()}
```

#### 정규 표현식

```json
{"x":/foobar/i}
```

#### 배열

값의 set이나 list를 배열로 표현할 수 있다.

```json
{"x": ["a", "b", "c"]}
```

#### 내장 도큐먼트

부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함할 수 있다.

```json
{"x": {"foo":"bar"}}
```

#### 객체 ID

도큐먼트용 12바이트 ID이다. (2.6.5)

```json
{"x": ObjectId()}
```

#### 이진 데이터

임의의 바이트 문자열이며 셸에서는 조작이 불가능하고 UTF-8이 아닌 문자열을 저장하는 유일한 방법이다.

#### 코드 

임의의 자바스크립트 코드를 포함할 수 있다.

```json
{"x": function() {~}}
```

### 2.6.2 날짜

new Date()를 호출해서 새로운 Date 객체를 생성한다.

Date()로 함수를 호출하면 새로운 객체를 생성하지 않고 날짜의 문자열을 반환한다. 이는 자바스크립트의 작동 방식 때문이다. 문자열과 날짜는 일치하지 않는다.

### 2.6.3 배열

배열은 정렬 연산(리스트, 스택, 큐)과 비정렬 연산(셋)에 호환성 있게 사용 가능하다.

```json
{"things": ["pie", 3.14]}
```

배열은 서로 다른 데이터형을 값으로 포함할 수 있고, 중첩 배열도 가능하다. 배열에 쿼리하거나 배열의 내용으로 인덱스를 만들 수 있다. 예를 들면 3.14가 things 배열의 요소인 모든 도큐먼트를 쿼리할 수 있다. things는 인덱스를 생성할 수 있다. 배열 내부의 값을 수정할 수 있다.

### 2.6.4 내장 도큐먼트

도큐먼트는 키에 대한 값이 될 수 있다. 이를 내장 도큐먼트라고 한다.

```json
{
	"name"; "John Doe",
	"address": {
		"street": "123 Park Street",
		"city": "Anytown",
		"state": "NY"
	}
}
```

“address” 의 값은 내장 도큐먼트이다.

이 도큐먼트는 관계형 디비는 people, addresses 두 개의 테이블에 분리된 두 행으로 모델링된다. 몽고디비에서는 people 도큐먼트 내에 addresses 도큐먼트를 내장할 수 있다.

하지만 더 많은 데이터 반복이 생길 수 있는 단점이 있다. 예를 들어 주소의 오타를 수정해야 한다면 몽고디비에서는 각 사람의 도큐먼트에서 오타를 수정해야 한다.

### 2.6.5 _id와 ObjectId

모든 도큐먼트는 “_id” 키를 가지고 ObjectId 데이터형이 기본이고 어떤 데이터형이어도 상관없다. 이 값은 컬렉션 내 모든 도큐먼트가 고유하게 식별된다.

#### ObjectIds

12바이트 스토리지를 사용하며 24자리 16진수 문자열 표현이 가능하다. 16진수로 표현되지만 실제 문자열은 저장된 데이터의 두 배 만큼 길다.

여러 개의 새로운 ObjectId를 연속해서 생성하면 마지막 숫자 몇 개만 바뀐다.

```json
0  1  2  3  4  5  6  7  8  9  10  11 (12 바이트)
타임 스탬프    랜덤            카운터(랜덤 시작 값)
```

- 첫 4바이트는 타임 스탬프이다.
    - 타임스탬프는 그 다음 5바이트와 묶일 때 초 단위의 유일성을 제공한다.
    - ObjectId는 입력 순서대로 정렬된다. 이 특성으로 ObjectId를 효율적으로 인덱싱한다.
    - 대부분의 드라이버는 ObjectId로부터 도큐먼트가 생성된 잠재적인 타임스탬프를 추출할 수 있도록 기능을 제공한다.
    - 현재 시간이 사용되기 때문에 서버 시각을 동기화해야 하냐는 질문을 할 수 있지만 타임스탬프의 실제 값은 ObjectId와 상관없기때문에 반드시 동기화하지 않아도 된다.
- 다음 5바이트는 랜덤값이다.
- 최종 3바이트는 서로 다른 시스템에서 충돌하는 ObjectId를 생성하지 않도록 랜덤 값으로 시작하는 카운터이다.
- 앞 9바이트는 1초 동안 여러 장비와 프로세스에 걸쳐 유일성을 보장하고, 마지막 3바이트는 단순 증분 숫자다.

#### _id 자동 생성

도큐먼트를 입력할 때 “_id”를 명시하지 않으면 자동으로 추가된다.

## 2.7 몽고DB 셸 사용

다른 장비나 포트에 mongod를 연결하려면 셸을 시작할 때 호스트명, 포트, 데이터베이스를 명시해야 한다.

```bash
> mongo some-hose:30000/myDB
```

—modb옵션을 써서 mongo 셸을 시작할 때 mongod에 연결하지 않을 수 있다. 원하는 때에 new Mongo(호스트명)으로 mongod에 연결할 수 있다.

```bash
> mongo --nodb
```

### 2.7.1 셸 활용 팁

help 로 셸에 내장된 도움말을 볼 수 있다. 

```bash
> help
db.help() //디비 수준의 도움말
db.foo.help() //컬렉션 수준의 도움말
```

함수의 기능을 알고 싶으면 함수명을 괄호 없이 입력한다. 그러면 함수의 자바스크립트 소스코드가 출력된다.

```bash
> db.movies.updateOne
```

### 2.7.2 셸에서 스크립트 실행하기

셸을 대화형으로 사용하는 법 외에 자바스크립트 파일을 셸로 전달해서 사용할 수 도 있다.

```bash
> mongo script1.js script2.js script3.js
```

기본값으로 지정되지 않은 호스트나 포트 mongod 에 연결해 사용하는 스크립트를 사용하려면 먼저 주소를 지정한다. —quite 옵션으로 print가 보이지 않도록 할 수 있다.

스크립트는 db 변수에 대한 접근 권한을 가지지만 use db나 show collections와 같은 셸 보조자는 파일에서 동작하지 않는다.

| 셸 보조자 | 같은 의미의 자바스크립트 |
| --- | --- |
| use video | db.getSisterDB(”video”) |
| show dbs | db.getMongo().getDBs() |
| show collections | db.getCollectionNames() |

스크립트를 사용해서 셸에 변수를 입력할 수 있다. 

기본적으로 셸을 시작한 디렉토리에서 스크립트를 찾고, 다른 경로에 있다면 상대경로 혹은 절대 경로를 제공하면 된다. run 함수로 명령행 프로그램을 실행할 수 있다. 파이프라인을 지원하지 않는다.

### 2.7.3 .mongorc.js 만들기

자주 로드되는 스크립트를 .mongorc.js에 넣을 수 있다. 디비, 컬렉션, 인덱스 삭제 방지 함수를 수행하지 않게 재정의할 수 있다. —norc 옵션으로 .mongorc.js 로딩을 비활성화할 수 있다.

### 2.7.4 프롬프트 커스터마이징하기

기본 셸 프롬프트는 문자열이나 함수에 prompt 를 설정해 재정의한다.

```bash
//마지막 작업이 완료된 시각을 얻기 위해 현재 시각을 출력하는 프롬프트를 만든다.
prompt = function() {
	return (new Date()) + "> ";
}
```

### 2.7.5 복잡한 변수 수정하기

다중행 지원은 다소 제한적이고 이전 행들을 편집할 수 없으며 몇 번째 줄에서 오류인지 확인하기 어렵다. 이땐 편집기에서 편집하면 좋다.

```bash
> EDITOR = "/user/bin/emacs"
```

Editor = “EDITOR 경로" 를 .mongorc.js 파일에 추가하면 된다.

### 2.7.6 불편한 컬렉션명

컬렉션 명이 유효하면 db.collectionName 구문으로 가져올 수 있다. 또는 배열 접근 구문을 사용해 유효하지 않은 속성명을 피할 수 있다. 자바스크립트에서 x.y 는 x[’y’] 와 동일한데 이는 서브 컬렉션이 상수 이름 뿐 아니라 변수를 이용해서도 접근할 수 있음을 의미한다.

```bash
var collections = ["posts", "comments", "authors"];

for(var i in collections) {
	print(db.blog[collections[i]]);
}
```

i가 변수로 해석되려면 db.blog[i]구문을 사용해야 하고, 위의 for문의 i는 인덱스이다.
