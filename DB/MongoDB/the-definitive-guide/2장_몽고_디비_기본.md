몽고디비는,

- 데이터의 기본 단위는 도큐먼트이고 관계형 디비의 행과 유사하다.(더 다양한 자료 표현 가능 → 이 뭘까?)
- 컬렉션은 동적 스키마가 있는 테이블과 같다.(동적 스키마?)
- 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 독립적인 데이터베이스를 호스팅한다.
- 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 “_id”를 가진다.
- 몽고 셸과 함께 배포된다. 몽고의 인스턴스를 관리하고 쿼리 언어로 데이터를 조작하며 스크립트를 로드할 수 있는 자바스크립트 해석기(Javascript interpreter)가 있다.

## 2.1 도큐먼트

도큐먼트는 정렬된 키와 연결된 값의 집합으로 이루어져 있다. 표현 방식은 대부분의 언어에서 맵, 해시, 딕셔너리와 같은 자료구조를 가진다. 예를 들어 자바스크립트에서 도큐먼트는 객체로 표현된다.

```json
{"greeting" : "Hello, world!"}
```

도큐먼트의 값은 단지 blob형이 아니고, 값은 데이터형 또는 내장 도큐먼트 전체가 되기도 한다. 도큐먼트의 키는 문자열이고 몇 가지 예외를 제외하면 어떤 UTF-8 문자든 쓸 수 있다.

- \0(null)을 포함하지 않는다. 키의 끝을 나타내는 데 사용된다.
- . 과 $ 문자는 특정 상황에서만 사용해야 하고 보통 예약어로 취급해야 한다.

```json
{"count":5}
{"count":"5"}
```

위의 두 다큐먼트는 서로 다르다. 또, 몽고디비에서 키는 중복될 수 없다.

```json
{"greeting":"Hello", "greeting":"Mongo DB!"}
```

## 2.2 컬렉션

컬렉션은 도큐먼트의 모음이다. 관계형 디비의 테이블에 대응된다.

### 2.2.1. 동적 스키마

컬렉션은 동적 스키마를 가진다. 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다. 

다른 구조의 도큐먼트라도 같은 컬렉션에 저장할 수 있는데 왜 별도의 컬렉션이 필요할까?

1. 같은 컬렉션에 저장하면 개발자와 관리자가 번거로워진다. 쿼리한 코드가 다른 구조의 도큐먼트를 다루지 못할 수도 있기 때문이다.
2. 컬렉션 별로 목록을 뽑으면 한 컬렉션 내에서 목록을 뽑을 때보다 훨씬 빠르다.
3. 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성(data locality)에 좋다. 컬렉션에서 추출할 때 디스크 탐색 시간이 더 짧다.
4. 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 해서 컬렉션 별로 인덱스를 정의해야 한다.

스키마를 만들고 도큐먼트를 그룹화해서 정의하면 도큐먼트 유효성 검사, 객체-도큐먼트 매핑 라이브러리를 이용할 수 있다.

### 2.2.2. 네이밍

컬렉션은 이름으로 식별되며 몇 가지 예외를 제외하고 어떤 UTF-8문자열도 쓸 수 있다.

- 빈 문자열(””)은 유효한 컬렉션 명이 아니다.
- \0(null)은 컬렉션 명의 끝을 의미하기 때문에 사용할 수 없다.
- system. 으로 시작하는 컬렉션 명은 예약어이다.
    - system.users : 데이터베이스 사용자 정보
    - system.namespaces: 디비 모든 컬렉션 정보
- 사용자가 만든 컬렉션에는 예약어인 $를 포함할 수 없다.

#### 서브컬렉션

서브컬렉션의 네임스페이스에 마침표(.)를 사용해서 컬렉션을 체계화한다. 예를 들면 blog.posts, blog.authors 라는 컬렉션을 가질 수 있고, 이는 체계화를 위한 용도이고 blob이나 자식커렉션의 의미가 아니다.

- 큰 파일을 저장하는 프로토콜인 GridFS는 콘텐츠 데이터와는 별도로 메타데이터를 저장하는 데 서브컬렉션을 사용한다.
- 대부분의 드라이버는 서브컬렉션에 접근하는 문법을 제공한다.

## 2.3 데이터베이스

몽고디비는 컬렉션에 도큐먼트를 그룹화하고, 데이터베이스에 컬렉션을 그룹화한다. 단일 인스턴스는 여러 데이터베이스를 호스팅할 수 있고 각 데이터베이스를 완전히 독립적으로 취급할 수 있다. 한 애플리케이션의 데이터를 동일한 데이터베이스에 저장하는 것은 좋은 방식이다. 데이터베이스를 나누면 하나의 몽고디비 서버에서 여러 애플리케이션이나 여러 사용자 데이터를 저장할 떄 유용하다.(→ 몽고도 디비를 나눌 수 있으니까 별도의 트랜잭션 매니저를 만드는 게 좋겠다.)

데이터베이스는 컬렉션과 마찬가지로 이름으로 식별되고 몇 가지 제한이 있다.

1. 빈 문자열(””)은 쓸 수 없다.
2. / , \ , . , ‘ ‘, * , < ,> , : , | , ? , $ , \0(null) 은 쓸 수 없다.
3. 대소문자를 구별한다.
4. 최대 64바이트이다. (영문만 쓰면 64자)

특별한 의미론(시멘틱)을 갖는 예약된 데이터베이스도 있다.

### admin

인증(authentification)과 권한 부여(authorization) 역할을 한다. 일부 관리 작업은 admin 에 대한 접근이 필요하다(19장).

### local

단일 서버에 대한 데이터를 저장한다. 복제 셋(replica set)에서 local은 복제 프로세스에 사용된 데이터를 저장하고, local 자체는 복제되지 않는다(10장)

### config

샤딩된 몽고 디비 클러스터(14장)는 config 에 각 샤드의 정보를 저장한다.

데이터베이스.컬렉션명 하면 네임스페이스를 얻는다. 예를 들어서 cms.blog.posts 네임스페이스는 cms 데이터베이스의 blog.posts 컬렉션을 사용하는 것이다. 네임스페이스의 최대 길이는 120바이트이지만 실제로는 100바이트보다 짧아야 한다.

## 2.4 몽고디비 시작

```bash
> mongod
```

argument 없이 실행하면 기본 데이터 디렉토리로 /data/db 를 사용하고, 존재하지 않거나 권한이 없으면 서버가 시작되지 않는다.

## 2.5 몽도디비 셸 소개

명령행에서 몽고디비 인스턴스와 상호작용하는 자바스크립트 셸을 제공하며, 관리 기능이나 실행 중인 인스턴스 점검, 간단한 기능 시험 등을 할 수 있다.

### 2.5.1 셸 실행

```bash
> mongo
> x = 200;
200
> x/5;
40
```

또, 표준 자바스크립트 라이브러리의 모든 기능을 사용할 수 있다.

```bash
> Math.sin(Math.PI / 2)
1
> new Date("20109/1/1");
ISODATE("2019091091T05:00:00Z")
```

자바스크립트 함수를 정의하고 호출할 수도 있다. 엔터키를 눌렀을 때 구문이 완료되지 않았으면 계속 명령어를 입력할 수 있다. 엔터를 3회 누르면 작성하던 명령을 취소하고 > 프롬프트를 반환한다.

### 2.5.2 몽고디비 클라이언트

셸은 시작할 때 test 데이터베이스에 연결하고 데이터베이스 연결을 전역 변수 db에 할당해서 접근한다.

```bash
> db
test
```

SQL 셸 사용자에게 친숙한 추가 기능을 포함해서 편리한 문법을 제공한다.

```bash
> use video //video 데이터베이스 사용 
> db
video
> db.movies //movies 컬렉션 반환 
```

### 2.5.3 셸 기본 작업

#### 생성

insertOne 함수는 컬렉션에 도큐먼트를 추가한다.

```bash
movie = {"title" : "Star Wars", "director": "George Lucas", "year": 1977}
db.movies.insertOne(movie)
db.getCollection("movie").insertOne(movie)
db.getCollection("movie").find({}).pretty()
```

“_id” 키가 추가됐다.

#### 읽기

find와 findOne으로 컬렉션을 쿼리한다.

```bash
> db.movies.findOne()
db.getCollection("movie").find({})
```

쿼리 도큐먼트 형태로 조건 전달할 수 있다.(4장)

#### 갱신

updateOne을 사용하고, 매개변수는 최소 2개이다. 첫 번째는 수정할 도큐먼트를 찾고, 두 번째는 갱신 작업을 설명한다. 갱신은 set을 이용한다.(3.3장)

```bash
> db.movies.updateOne({title: "Star Wars'}, ...{$set: {reviews:[]}})
db.getCollection("movie").updateOne({"title":"Star Wars"}, {$set: {"title":"Star Ward Updated"}})
```

#### 삭제

deleteOne과 deleteMany는 도큐먼트를 데이터베이스에서 영구적으로 삭제한다. 필터 도큐먼트로 삭제 조건을 지정한다.

```bash
> db.movies.deleteOne({title:"Star Wars"})
db.getCollection("movie").deleteOne({"title":"Star Wars"})
```

## 2.6 데이터형

### 2.6.1 기본 데이터형

JSON 과 닮았지만 JSON은 데이터형이 null, bool, number, string, array, object만 지원하기 때문에 표현이 제한적이다. 몽고는 키값 쌍 성질을 유지하면서 추가적인 데이터형을 지원한다.

#### null

```json
{"x": null}
```

#### 불리언

```json
{"x":true}
```

#### 숫자

64비트 부동소수점 수를 기본으로 사용한다.

```json
{"x":3}
```

4바이트나 8바이트 부호 정수는 NumberInt나 NumberLong을 사용한다.

```json
{"x":NumberInt("3")}
```

#### 문자

UTF-8이면 어떤 문자든 표현가능

```json
{"x": "foobar"}
```

#### 날짜

1970년 1월 1일부터 1/1000 초 단위로 나타내는 64비트 정수로 저장한다. 표준 시간대(time zone)는 저장하지 않는다.

```json
{"x":new Date()}
```

#### 정규 표현식

```json
{"x":/foobar/i}
```

#### 배열

값의 set이나 list를 배열로 표현할 수 있다.

```json
{"x": ["a", "b", "c"]}
```

#### 내장 도큐먼트

부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함할 수 있다.

```json
{"x": {"foo":"bar"}}
```

#### 객체 ID

도큐먼트용 12바이트 ID이다. (2.6.5)

```json
{"x": ObjectId()}
```

#### 이진 데이터

임의의 바이트 문자열이며 셸에서는 조작이 불가능하고 UTF-8이 아닌 문자열을 저장하는 유일한 방법이다.

#### 코드 

임의의 자바스크립트 코드를 포함할 수 있다.

```json
{"x": function() {~}}
```

### 2.6.2 날짜

### 2.6.3 배열

### 2.6.4 내장 도큐먼트

### 2.6.5 _id와 ObjectId

#### ObjectIds

#### _id 자동 생성

## 2.7 몽고DB 셸 사용

### 2.7.1 셸 활용 팁

### 2.7.2 셸에서 스크립트 실행하기

### 2.7.3 .mongorc.js 만들기

### 2.7.4 프롬프트 커스터마이징하기

### 2.7.5 복잡한 변수 수정하기

### 2.7.6 불편한 컬렉션명
